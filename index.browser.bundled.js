// node_modules/jqlmodule/Bundle/jql.min.js
var Nt = "url('data:image/svg+xml\\3butf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22iso-8859-1%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20version%3D%221.1%22%20id%3D%22Layer_1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20128%20128%22%20style%3D%22enable-background%3Anew%200%200%20128%20128%3B%22%20xml%3Aspace%3D%22preserve%22%3E%3Crect%20x%3D%22-368%22%20y%3D%226%22%20style%3D%22display%3Anone%3Bfill%3A%23E0E0E0%3B%22%20width%3D%22866%22%20height%3D%221018%22%2F%3E%3Ccircle%20style%3D%22fill%3A%23FFFFFF%3B%22%20cx%3D%2264%22%20cy%3D%2264%22%20r%3D%2248%22%2F%3E%3Ccircle%20style%3D%22fill%3A%238CCFB9%3B%22%20cx%3D%2264%22%20cy%3D%2264%22%20r%3D%2239%22%2F%3E%3Ccircle%20style%3D%22fill%3Anone%3Bstroke%3A%23444B54%3Bstroke-width%3A6%3Bstroke-miterlimit%3A10%3B%22%20cx%3D%2264%22%20cy%3D%2264%22%20r%3D%2248%22%2F%3E%3Cpolyline%20style%3D%22fill%3Anone%3Bstroke%3A%23FFFFFF%3Bstroke-width%3A6%3Bstroke-linecap%3Around%3Bstroke-miterlimit%3A10%3B%22%20points%3D%2242%2C69%2055.55%2C81%20%20%2086%2C46%20%22%2F%3E%3C%2Fsvg%3E')";
var K = Jt();
var ft = Bt();
var q = kt();
var _ = Ot();
function kt() {
  return { html: "accept,action,align,alt,autocapitalize,autocomplete,autopictureinpicture,autoplay,background,bgcolor,border,capture,cellpadding,cellspacing,checked,cite,class,clear,contenteditable,color,cols,colspan,controls,controlslist,coords,crossorigin,datetime,decoding,default,dir,disabled,disablepictureinpicture,disableremoteplayback,download,draggable,enctype,enterkeyhint,face,for,headers,height,hidden,high,href,hreflang,id,inputmode,integrity,ismap,kind,label,lang,list,loading,loop,low,max,maxlength,media,method,min,minlength,multiple,muted,name,nonce,noshade,novalidate,nowrap,open,optimum,pattern,placeholder,playsinline,poster,preload,pubdate,radiogroup,readonly,rel,required,rev,reversed,role,rows,rowspan,spellcheck,scope,selected,shape,size,sizes,span,srclang,start,src,srcset,step,style,summary,tabindex,target,title,translate,type,usemap,valign,value,width,xmlns,slot".split(","), svg: "accent-height,accumulate,additive,alignment-baseline,ascent,attributename,attributetype,azimuth,basefrequency,baseline-shift,begin,bias,by,class,clip,clippathunits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,cx,cy,d,dx,dy,diffuseconstant,direction,display,divisor,dur,edgemode,elevation,end,fill,fill-opacity,fill-rule,filter,filterunits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,fx,fy,g1,g2,glyph-name,glyphref,gradientunits,gradienttransform,height,href,id,image-rendering,in,in2,k,k1,k2,k3,k4,kerning,keypoints,keysplines,keytimes,lang,lengthadjust,letter-spacing,kernelmatrix,kernelunitlength,lighting-color,local,marker-end,marker-mid,marker-start,markerheight,markerunits,markerwidth,maskcontentunits,maskunits,max,mask,media,method,mode,min,name,numoctaves,offset,operator,opacity,order,orient,orientation,origin,overflow,paint-order,path,pathlength,patterncontentunits,patterntransform,patternunits,points,preservealpha,preserveaspectratio,primitiveunits,r,rx,ry,radius,refx,refy,repeatcount,repeatdur,restart,result,rotate,scale,seed,shape-rendering,specularconstant,specularexponent,spreadmethod,startoffset,stddeviation,stitchtiles,stop-color,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke,stroke-width,style,surfacescale,systemlanguage,tabindex,targetx,targety,transform,text-anchor,text-decoration,text-rendering,textlength,type,u1,u2,unicode,values,viewbox,visibility,version,vert-adv-y,vert-origin-x,vert-origin-y,width,word-spacing,wrap,writing-mode,xchannelselector,ychannelselector,x,x1,x2,xmlns,y,y1,y2,z,zoomandpan".split(",") };
}
function Ot() {
  return { a: true, area: true, audio: false, br: true, base: true, body: true, button: true, canvas: true, dl: true, data: true, datalist: true, div: true, em: true, embed: false, fieldset: true, font: false, footer: true, form: false, hr: true, head: true, header: true, output: true, iframe: false, frameset: false, img: true, input: true, li: true, label: true, legend: true, link: true, map: true, mark: true, menu: true, media: true, meta: true, nav: true, meter: true, ol: true, object: false, optgroup: true, option: true, p: true, param: true, picture: true, pre: true, progress: false, quote: true, script: false, select: true, source: true, span: true, style: true, caption: true, td: true, col: true, table: true, tr: true, template: false, textarea: true, time: true, title: true, track: true, details: true, ul: true, video: true, del: true, ins: true, slot: true, blockquote: true, svg: true, dialog: true, summary: true, main: true, address: true, colgroup: true, tbody: true, tfoot: true, thead: true, th: true, dd: true, dt: true, figcaption: true, figure: true, i: true, b: true, code: true, h1: true, h2: true, h3: true, h4: true, abbr: true, bdo: true, dfn: true, kbd: true, q: true, rb: true, rp: true, rt: true, ruby: true, s: true, strike: true, samp: true, small: true, strong: true, sup: true, sub: true, u: true, var: true, wbr: true, nobr: false, tt: true, noscript: true };
}
function Jt() {
  return ["#logBox{min-width:0px;max-width:0px;min-height:0px;max-height:0px;,width:0;height:0;z-index:-1;border:none;padding:0px;overflow:hidden;transition:all 0.3s ease;margin-top:-100px;}", "#logBox.visible{background-color:rgb(255, 255, 224);z-index:1;position:static;border:1px dotted rgb(153, 153, 153);max-width:50vw;min-width:30vw;min-height:10vh;max-height:90vh;overflow:auto;width:50vw;height:20vh;margin:1rem 0px;padding:0px 8px 19px;resize:both;}", "#logBox.visible .legend{position:absolute;}", "#logBox .legend{text-align:center;margin-top:-1em;width:inherit;max-width:inherit;}", "#logBox .legend div{text-align:center;display:inline-block;max-width:inherit;height:1.2rem;background-color:rgb(119, 119, 119);padding:2px 10px;color:rgb(255, 255, 255);box-shadow:rgb(119 119 119) 2px 1px 10px;border-radius:4px;}", "#logBox .legend div:before{content:'JQL Logging (chronological)';}", "#logBox .legend.reversed div:before{content:'JQL Logging (reversed)';}", "#logBox #jql_logger{marginTop:0.7rem;lineHeight:1.4em;font-family:consolas,monospace;whiteSpace:pre-wrap;maxWidth:inherit;padding-left:100px;}", "#logBox #jql_logger div.entry{text-indent:-100px;whiteSpace:normal;}"];
}
function Bt() {
  return [".popupContainer{position:fixed;inset:-5000px;opacity:0;height:0;width:0;background:rgba(0,0,0,0.1);transition:opacity 0.6s ease-in-out 0s;}", ".popupContainer.popup-active{opacity:1;inset:0;height:auto;width:auto;}", ".popupContainer .content{box-shadow:rgba(0,0,0,0.5) 2px 2px 8px;border-radius:3px;min-width:125px;max-width:40vw;max-height:40vh;padding:8px;overflow:auto;background:#FFF;z-index:inherit;opacity:1;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);}", ".popupContainer .content .popup-warn{position:relative;padding:3px 8px 0 8px;color:red;margin:6px -8px -4px -8px;text-align:center;display:none;}", ".popupContainer .content.popup-warn-active .popup-warn{display:block;border-top:1px dashed rgb(0,0,0);}", `.closeHandleIcon{z-index:1;position:absolute;opacity:0;cursor:pointer;width:24px;height:24px;background:${Nt} no-repeat;}`, ".closeHandleIcon.popup-active{opacity:1;}", "@media screen and (width < 1200px){.popupContainer .content{max-width:75vw;}}", "@media screen and (width < 640px){.popupContainer .content{max-width:90vw;max-height:60vw;}}"];
}
var tt = false;
var Pt = { on: () => tt = true, off: () => tt = false };
var D = { tagsRaw: _, allowUnknownHtmlTags: Pt, isAllowed(t) {
  if (tt)
    return true;
  let e = t?.nodeName.toLowerCase() || "none";
  return e === "#text" || !!_[e];
}, allowTag: (t) => _[t.toLowerCase()] = true, prohibitTag: (t) => _[tag.toLowerCase()] = false };
var nt = false;
var U = false;
var O = true;
var ot = false;
var Qt = true;
var yt;
var k = () => y("#logBox");
var xt = "#jql_logger";
var zt = (t) => {
  K?.forEach((e) => t(e));
};
var Wt = () => {
  K && zt(yt);
  let t = Qt ? "div" : "pre", e = `<div id="logBox"><div class="legend"><div></div></div><${t} id="jql_logger"></${t}></div>`;
  return it(F(e), void 0, H.AfterBegin), y.node(xt);
};
var ht = (t) => a(t, String) && Object.assign(document.createElement("textarea"), { innerHTML: t }).textContent || t;
var A = (...t) => {
  let e = t[0] === "fromStatic";
  if (t = e ? t.slice(1) : t, e && !U)
    return t.forEach((n) => console.info(`${J()} \u2714 ${ht(n)}`));
  if (!U)
    return;
  !O && !y.node("#logBox") && (yt = y.createStyle("JQLLogCSS"), Wt());
  let r = (n) => `${a(n, Object) ? JSON.stringify(n, null, 2) : n}
`;
  t.forEach((n) => O ? console.info(`${J()} \u2714 ${ht(n)}`) : y.node("#jql_logger").insertAdjacentHTML(ot ? "afterbegin" : "beforeend", `<div class="entry">${J()} ${r(n.replace(/\n/g, "<br>"))}</div>`));
};
var et = { on() {
  U = true, A("Logging activated");
}, off() {
  U = false, console.log("Logging deactivated");
} };
var rt = { on() {
  nt = true;
}, off() {
  nt = false;
} };
var B = (...t) => nt && A(...t);
var $ = { get isConsole() {
  return O === true;
}, isOn: () => U, isVisible: () => y("#jql_logger").is("visible"), on: () => (et.on(), rt.on(), O || k()?.addClass("visible"), A("Debug logging started. Every call to [jql instance] is logged"), $), off: () => (k().isEmpty || (rt.off(), A("Debug logging stopped"), k()?.removeClass("visible")), et.off(), $), toConsole: { on: () => (O = true, A("Started logging to console"), $), off() {
  return A("Stopped logging to console (except error messages)"), O = false, $;
} }, remove: () => (et.off(), rt.off(), k()?.remove(), console.clear(), console.log(`${J()} logging completely disabled and all entries removed`), $), log: (...t) => (A(...t), $), hide: () => (k()?.removeClass("visible"), $), show: () => (k()?.addClass("visible"), $), reversed: { on: () => (ot = true, A("Reverse logging set: now logging bottom to top (latest first)"), y("#logBox .legend").addClass("reversed"), $), off: () => (ot = false, y("#logBox .legend").removeClass("reversed"), A("Reverse logging reset: now logging chronological (latest last)"), $) }, clear: () => (y(xt).text(""), console.clear(), A("Logging cleared"), $) };
var a = bt;
function bt(t, ...e) {
  let r = ["NaN", "null", "undefined"], n = (h) => typeof h == "symbol" ? Symbol : h;
  return e.length > 1 ? u(t, ...e) : o();
  function o() {
    let h = n(t), x = e.length > 0;
    return e = x && e.shift(), x && s(e) ? `${h}` == `${e}` : t === false ? e === Boolean ? true : "Boolean" : w();
    function w() {
      let E = t === 0 ? Number : t === "" ? String : h ? Object.getPrototypeOf(t)?.constructor : { name: `${h}` };
      return e ? e === E || e === Object.getPrototypeOf(E) || `${e}` === E?.name : E?.name;
    }
  }
  function s(h) {
    for (let x of r)
      if (x === `${h}`)
        return true;
    return false;
  }
  function u(h, ...x) {
    for (let p of x)
      if (bt(h, p))
        return true;
    return false;
  }
}
var qt = [...Array(26)].map((t, e) => String.fromCharCode(e + 65)).concat([...Array(26)].map((t, e) => String.fromCharCode(e + 97))).concat([...Array(10)].map((t, e) => `${e}`));
var Z = (t, e = 2) => `${t}`.padStart(e, "0");
var _t = (t, e = 0) => ([t, e] = [Math.floor(t), Math.ceil(e)], Math.floor([...crypto.getRandomValues(new Uint32Array(1))].shift() / 2 ** 32 * (t - e + 1) + e));
var Ut = (t) => {
  let e = t.length;
  for (; e--; ) {
    let r = _t(e);
    [t[e], t[r]] = [t[r], t[e]];
  }
  return t;
};
var I = (t, e = 120) => `${t}`.trim().slice(0, e).replace(/>\s+</g, "><").replace(/</g, "&lt;").replace(/\s{2,}/g, " ").replace(/\n/g, "\\n") + (t.length > e ? " &hellip;" : "").trim();
var P = (t) => t.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`).replace(/^-|-$/, "");
var Vt = ([t, ...e]) => `${t.toUpperCase()}${e.join("")}`;
var vt = (t) => a(t, String) ? t.toLowerCase().split("-").map((e, r) => r && `${Vt(e)}` || e).join("") : t;
var V = () => `_${Ut(qt).slice(0, 8).join("")}`;
var Y = (t, e = 120) => I(t, e).replace(/&lt;/g, "<");
var J = () => ((t) => `[${Z(t.getHours())}:${Z(t.getMinutes())}:${Z(t.getSeconds())}.${Z(t.getMilliseconds(), 3)}]`)(/* @__PURE__ */ new Date());
var Q = (t) => t.replace(/</g, "&lt;");
function Lt() {
  let t = function(s) {
    if (!s)
      return;
    let u = s.style, h = getComputedStyle(s), x = [u.visibility, h.visibility].includes("hidden"), p = [u.display, h.display].includes("none"), w = s.offsetTop < 0 || s.offsetLeft + s.offsetWidth < 0 || s.offsetLeft > document.body.offsetWidth, E = +h.opacity == 0 || +(u.opacity || 1) == 0;
    return !(w || E || p || x);
  }, e = function(s) {
    return !!y.nodes(":is(:read-write)", s.parentNode).find((u) => u === s);
  }, r = function(s) {
    return !!y.nodes(":is(:modal)", s.parentNode).find((u) => u === s);
  }, n = "n/a", o = { writable: n, modal: n, empty: true, open: n, visible: n };
  return (s) => {
    let u = s[0];
    return u ? { get writable() {
      return e(u);
    }, get modal() {
      return r(u);
    }, get open() {
      return u.open;
    }, get visible() {
      return t(u);
    }, get disabled() {
      return u.hasAttribute("readonly") || u.hasAttribute("disabled");
    }, get empty() {
      return false;
    }, get virtual() {
      return s.isVirtual;
    } } : o;
  };
}
var Gt = true;
var X = { data: /data-[\-\w.\p{L}]/ui, validURL: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, whiteSpace: /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g, notAllowedValues: /javascript|injected|noreferrer|alert|DataURL/gi };
var Zt = (t) => {
  if (Gt && Object.keys(t.removed).length) {
    let e = Object.entries(t.removed).reduce((r, [n, o]) => [...r, `${Q(n)} => ${o}`], []).join("\\000A");
    $.log(`JQL HTML creation errors: ${$.isConsole ? e : Q(e)}`);
  }
};
var St = (t) => {
  let e = { rawHTML: t.outerHTML, removed: {} };
  return a(t, HTMLElement) && [...t.childNodes].forEach((r) => {
    if (r?.attributes) {
      let o = a(r, SVGElement) ? q.svg : q.html;
      [...(r ?? { attributes: [] }).attributes].forEach((s) => {
        let u = s.name.trim().toLowerCase(), h = s.value.trim().toLowerCase().replace(X.whiteSpace, ""), x = u === "href" ? !X.validURL.test(h) : X.notAllowedValues.test(h), p = u.startsWith("data") ? !X.data.test(u) : !!o[u];
        if (x || p) {
          let w = Y(s.value || "none", 60);
          w += w.length === 60 ? "..." : "", e.removed[`${s.name}`] = `attribute/property (-value) not allowed, removed. Value: ${w}`, r.removeAttribute(s.name);
        }
      });
    }
    if (!D.isAllowed(r)) {
      let o = (r?.outerHTML || r?.textContent).trim(), s = Y(o, 60) ?? "EMPTY";
      s += s.length === 60 ? "..." : "", e.removed[`<${r.nodeName?.toLowerCase()}>`] = `not allowed, not rendered. Value: ${s}`, r.remove();
    }
  }), Zt(e), t;
};
var H = { BeforeBegin: "beforebegin", AfterBegin: "afterbegin", BeforeEnd: "beforeend", AfterEnd: "afterend" };
var st = document.createElement("div");
var Yt = (t) => (st.innerHTML = t, st.childNodes.length ? St(st) : void 0);
var Xt = (t, e, r) => a(t, Comment) ? e.insertAdjacentHTML(r, `<!--${t.data}-->`) : e.insertAdjacentText(r, t.data);
var z = (t = [], e = document.body, r = H.BeforeEnd) => t.reduce((n, o) => {
  let s = j(o) && it(o, e, r);
  return s ? [...n, s] : n;
}, []);
var it = (t, e = document.body, r = H.BeforeEnd) => (e = e?.isJQL ? e?.[0] : e, a(t, Comment, Text) ? Xt(t, e, r) : e.insertAdjacentElement(r, t));
var F = (t) => {
  if (a(t, Text, Comment))
    return t;
  let e = t.trim(), r = e.split(/<text>|<\/text>/i);
  if (r = r.length > 1 ? r.filter((o) => o.length).shift() : void 0, e.startsWith("<!--") && e.endsWith("-->"))
    return document.createComment(t.replace(/<!--|-->$/g, ""));
  if (r || !/^<(.+)[^>]+>/m.test(e))
    return document.createTextNode(r);
  let n = Yt(t);
  return n.childNodes.length < 1 ? F(`<span data-jqlcreationerror="1">${I(t, 60)}</span>`) : n.children[0];
};
var L = (t, e) => {
  let r = t.collection.filter((n) => !lt(n));
  for (let n = 0; n < r.length; n += 1)
    e(r[n], n);
  return t;
};
var Kt = Lt();
var Et = (t) => t && (t.textContent = "");
var te = (t, e) => t.toLowerCase().trim() === e.trim().toLowerCase();
var wt = (t, e) => {
  t && a(e, Object) && Object.entries(e).forEach(([r, n]) => t.setAttribute(`data-${P(r)}`, n));
};
var Ct = (t) => q.html.find((e) => t.toLowerCase() === e);
var ee = (t, e, r) => {
  r && a(e, String) && (e = { [e]: r === "-" ? "" : r });
  let n;
  e.className && (n = e.className, delete e.className), n = [...t.classList].find((s) => s.startsWith("JQLClass-") || n && s === n) || n || `JQLClass-${V().slice(1)}`, y.editCssRule(`.${n}`, e), t.classList.add(n);
};
var re = (t, e) => {
  t && Object.entries(e).forEach(([r, n]) => {
    if (r.toLowerCase().startsWith("data"))
      return wt(t, n);
    if (te(r, "class"))
      return n.split(/,/).forEach((o) => t.classList.add(`${o.trim()}`));
    if (a(n, String) && Ct(r))
      return t[r] = n;
  });
};
var at = (t, e) => {
  a(e, Object) && Object.entries(e).forEach(([r, n]) => {
    let o;
    /!important/i.test(n) && (n = n.slice(0, n.indexOf("!")).trim(), o = "important"), t.style.setProperty(P(r), n, o);
  });
};
var ne = { get(t, e) {
  return t[vt(e)] || t[e];
} };
var oe = { factoryExtensions: { is: (t) => Kt(t), length: (t) => t.collection.length, dimensions: (t) => t.first()?.getBoundingClientRect(), parent: (t) => {
  let e = y(t[0]?.parentNode);
  return e.is.empty ? t : e;
}, outerHtml: (t) => (t.first() || { outerHTML: void 0 }).outerHTML, data: (t) => ({ get all() {
  return new Proxy(t[0]?.dataset ?? {}, ne);
}, set: (e = {}) => (!t.is.empty && a(e, Object) && Object.entries(e).forEach(([r, n]) => t.setData({ [r]: n })), t), get: (e, r) => t.data.all[e] ?? r, add: (e = {}) => (!t.is.empty && a(e, Object) && Object.entries(e).forEach(([r, n]) => t.setData({ [r]: n })), t), remove: (e) => (t[0]?.removeAttribute(`data-${P(e)}`), t) }), Style: (t) => ({ get computed() {
  return t.is.empty ? {} : getComputedStyle(t[0]);
}, inline: (e) => t.style(e), inSheet: (e) => t.css(e), valueOf: (e) => t.is.empty ? void 0 : getComputedStyle(t[0])[P(e)], nwRule: (e) => t.Style.byRule({ rules: e }), byRule: ({ classes2Apply: e = [], rules: r = [] } = {}) => {
  let o = a(r, String) && !e.length ? r.split("{")[0].trim() : "";
  return r = r && a(r, String) ? [r] : r, e = e && a(e, String) ? [e] : e, (r?.length || e?.length) && (r?.length && y.editCssRules(...r), e?.forEach((s) => t.addClass(s))), o?.startsWith(".") && t.addClass(o.slice(1)), o?.startsWith("#") && !t.attr("id") && t.prop({ id: o.slice(1) }), t;
} }), HTML: (t) => ({ get: (e, r) => {
  if (t.is.empty)
    return "NO ELEMENTS IN COLLECTION";
  let n = e ? t.outerHtml : t.html();
  return r ? Q(n) : n;
}, set: (e, r = false, n = false) => {
  e = e.isJQL ? e.HTML.get(1) : e;
  let o = a(e, String);
  return e = o && n ? Q(e) : e, o && (e || "").trim().length && t.html(e, r), t;
}, replace: (e, r = false) => t.HTML.set(e, false, r), append: (e, r = false) => t.HTML.set(e, true, r), insert: (e, r = false) => (e = e.isJQL ? e.HTML.get() : e, t.HTML.set(e + t.HTML.get(), false, r)) }) }, instanceExtensions: { isEmpty: (t) => t.collection.length < 1, replaceClass: (t, e, ...r) => L(t, (n) => {
  n.classList.remove(e), r.forEach((o) => n.classList.add(o));
}), removeClass: (t, ...e) => L(t, (r) => r && e.forEach((n) => r.classList.remove(n))), addClass: (t, ...e) => L(t, (r) => r && e.forEach((n) => r.classList.add(n))), setData: (t, e) => L(t, (r) => wt(r, e)), show: (t) => L(t, (e) => at(e, { display: "revert-layer !important" })), hide: (t) => L(t, (e) => at(e, { display: "none !important" })), empty: (t) => L(t, Et), clear: (t) => L(t, Et), closest: (t, e) => {
  let r = a(e, String) ? t[0].closest(e) : null;
  return r ? y(r) : t;
}, style: (t, e, r) => L(t, (o) => {
  r && a(e, String) && (e = { [e]: r || "none" }), at(o, e);
}), toggleClass: (t, e) => L(t, (r) => r.classList.toggle(e)), css: (t, e, r) => L(t, (n) => ee(n, e, r)), text: (t, e, r = false) => t.isEmpty() ? t : a(e, String) ? L(t, (o) => o.textContent = r ? o.textContent + e : e) : t.first().textContent, removeAttribute: (t, e) => L(t, (r) => r.removeAttribute(e)), each: (t, e) => L(t, e), remove: (t, e) => {
  let r = (o) => o.remove(), n = () => t.collection = t.collection.filter((o) => document.documentElement.contains(o));
  if (e) {
    let o = t.find$(e);
    return o.is.empty || (L(o, r), n()), t;
  }
  return L(t, r), n(), t;
}, computedStyle: (t, e) => t.first() && getComputedStyle(t.first())[e], getData: (t, e, r) => t.first() && t.first().dataset?.[e] || r, hasClass: (t, ...e) => {
  let r = t[0];
  return !r || !r.classList.length ? false : e.find((n) => r.classList.contains(n)) && true || false;
}, replace: (t, e, r) => {
  let n = t[0];
  return !e || !r || !a(r, HTMLElement) && !r.isJQL ? (console.error("JQL replace: invalid replacement value"), t) : (r.isJQL && (r = r[0]), a(r, NodeList) && (r = r[0]), n && e && (e = a(e, String) ? n.querySelectorAll(e) : e.isJQL ? e.collection : e, a(e, HTMLElement, NodeList, Array) && a(r, HTMLElement) && (a(e, HTMLElement) ? [e] : [...e]).forEach((o) => o.replaceWith(r.cloneNode(true)))), t);
}, replaceWith: (t, e) => (e = a(e, Element) ? e : e.isJQL ? e[0] : void 0, e && (t[0].replaceWith(e), t = y.virtual(e)), t), replaceMe: (t, e) => t.replaceWith(e), val: (t, e) => {
  let r = t[0];
  return !r || !a(r, HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement) ? t : e === void 0 ? r.value : (r.value = a(e, String) ? e : "", t);
}, attr: (t, e, r) => !r && a(e, String) ? e === "class" ? [...t[0]?.classList].join(" ") : t[0]?.getAttribute(e) : (a(e, String) && r && (e = { [e]: r }), a(e, Object) && !t.is.empty && re(t[0], e), t), andThen: (t, e, r = false) => {
  e = e.isJQL ? e.collection : y.virtual(F(e)).collection;
  let [n, o, s] = r ? [0, "before", e.concat(t.collection)] : [t.collection.length - 1, "after", t.collection.concat(e)];
  return t[n][o](...e), t.collection = s, t;
}, afterMe: (t, e) => t.andThen(e), beforeMe: (t, e) => t.andThen(e, true), append: (t, ...e) => {
  if (!t.is.empty && e.length)
    for (let r of e) {
      if (a(r, String)) {
        let n = r.trim();
        r = !/^<(.+)[^>]+>$/m.test(n) ? y.text(r) : F(r), L(t, (s) => s.append(r));
      }
      if (j(r)) {
        let n = r;
        t.length > 1 && (n = r, n.removeAttribute && n.removeAttribute("id")), L(t, (o) => o.append(n));
      }
      if (r.isJQL && !r.is.empty) {
        let n = t.length > 1 ? r.duplicate().collection : r.collection;
        L(t, (o) => o.append(...n));
      }
    }
  return t;
}, prepend: (t, ...e) => {
  if (!t.isEmpty() && e)
    for (let r of e) {
      if (a(r, String)) {
        let n = !/^<.+>$/m.test(r.trim());
        L(t, (o) => o.prepend(n ? y.text(r) : F(r)));
      }
      if (j(r)) {
        let n = r;
        t.length > 1 && (n = r.cloneNode(true), n.removeAttribute && n.removeAttribute("id")), L(t, (o) => o.insertBefore(n, o.firstChild));
      }
      if (r.isJQL && !r.is.empty) {
        let n = t.length > 1 ? r.duplicate().collection : r.collection;
        L(t, (o) => o.prepend(...n));
      }
    }
  return t;
}, appendTo: (t, e) => (e.isJQL || (e = y(e)), e.append(t), t), prependTo: (t, e) => (e.isJQL || (e = y.virtual(e)), e.prepend(t), t), single: (t, e) => t.collection.length > 0 ? a(e, String) ? t.find$(e) : a(e, Number) ? y(t.collection[e]) : y(t.collection[0]) : t, toNodeList: (t) => [...t.collection].map((e) => document.importNode(e, true)), duplicate: (t, e = false, r = document.body) => {
  let n = t.toNodeList().map((s) => s.removeAttribute && s.removeAttribute("id") || s), o = y.virtual(n);
  return e ? o.toDOM(r) : o;
}, toDOM: (t, e = document.body, r = H.BeforeEnd) => (t.collection = z(t.collection, e, r), t.isVirtual && (t.isVirtual = false), t), first: (t, e = false) => {
  if (t.collection.length > 0)
    return e ? t.single() : t.collection[0];
}, first$: (t, e) => t.single(e), find: (t, e) => t.first()?.querySelectorAll(e) || [], find$: (t, e) => y(e, t), prop: (t, e, r) => {
  if (a(e, String) && !r)
    return t[0]?.[e];
  let n = a(e, Object) ? e : { [e]: r };
  return Object.entries(n).forEach(([o, s]) => {
    if (o = o.trim(), s && !Ct(o) || !s)
      return false;
    let u = o.toLowerCase() === "id";
    u && (t[0].id = s), !u && L(t, (h) => h[o] = s);
  }), t;
}, on: (t, e, ...r) => (t.collection.length && r?.forEach((n) => {
  let o = $t(t);
  y.delegate(e, o, n);
}), t), html: (t, e, r) => {
  if (e === void 0)
    return t[0]?.innerHTML;
  if (!t.isEmpty()) {
    let n = F(`<div>${e.isJQL ? e.HTML.get(true) : e}</div>`);
    if (!a(n, Comment))
      return L(t, (s) => s.innerHTML = r ? s.innerHTML + n.innerHTML : n.innerHTML);
  }
  return t;
}, htmlFor: (t, e, r = "", n = false) => {
  if (e && t.collection.length) {
    let o = t.find$(e);
    if (!o)
      return t;
    if ("{htmlValue}".trim().length < 1)
      return o.textContent = "", t;
    let s = F(`<div>${r}</div>`);
    s && o.html(s.innerHTML, n);
  }
  return t;
}, trigger: (t, e, r = Event, n = {}) => {
  if (t.collection.length) {
    let o = new r(e, { ...n, bubbles: n.bubbles ?? true });
    for (let s of t.collection)
      s.dispatchEvent(o);
  }
  return t;
} } };
var ct = oe;
var Tt = ie;
function ie(t) {
  let e = t.createStyle("JQLPopupCSS");
  ft.forEach((i) => e(i));
  let r, n, o, s, u = t.virtual('<div class="popup-warn">'), h = t('<div class="popupContainer">').append(t('<span class="closeHandleIcon">')).append(t('<div class="content">')), [x, p] = [t(".popupContainer > .closeHandleIcon"), t(".popupContainer > .content")], w = () => {
    if (x.hasClass("popup-active")) {
      let { x: i, y: l, width: f } = p.dimensions;
      x.style({ top: `${l - 12}px`, left: `${i + f - 12}px` });
    }
  }, E = (i, l = false) => {
    let f = l ? i.min - 100 : i.max + 10;
    h.style({ zIndex: f }), x.style({ zIndex: f + 1 });
  }, R = () => {
    o && t(".popup-warn").clear().append(t(`<div>${o}</div>`)), p.addClass("popup-warn-active");
  }, S = () => {
    r = false, d(x[0]);
  }, C = () => {
    let i = [0, ...t.nodes("*:not(.popupContainer, .closeHandleIcon)", document.body).map((l) => +getComputedStyle(l).zIndex).filter((l) => t.IS(l, Number))];
    return { max: Math.max(...i) ?? 0, min: Math.min(...i) ?? 0 };
  }, M = (i, l) => s = setTimeout(() => d(x[0]), +i * 1e3);
  return E(C(), true), t.delegate("click", ".popupContainer, .closeHandleIcon", (i) => d(i.target)), t.delegate("click", ".popupContainer .content", (i, l) => r && l.removeClass("popup-warn-active")), t.delegate("resize", w), { show: m, create: (i, l, f, v) => {
    let c = t.IS(l, Boolean) ? l : false;
    m({ content: i, modal: c, callback: c ? f : l, warnMessage: v });
  }, createTimed: (i, l, f) => m({ content: i, closeAfter: l, callback: f }), removeModal: S };
  function m({ content: i, modal: l, closeAfter: f, callback: v, warnMessage: c }) {
    return i ? (clearTimeout(s), E(C()), r = l ?? false, o = t.IS(c, String) && `${c?.trim()}`.length || c?.isJQL ? c : void 0, p.clear().append(i.isJQL ? i : t(`<div>${i}</div>`)), r && c && p.append(u.duplicate()), h.addClass("popup-active"), t.IS(v, Function) && (n = () => {
      v(), n = null;
    }), r || (t.IS(+f, Number) && M(f, n), x.addClass("popup-active"), w()), true) : console.error("Popup creation needs at least some text to show");
  }
  function d(i) {
    if (!r && !i.closest(".content")) {
      clearTimeout(s), p.clear(), t(".popup-active").removeClass("popup-active"), E(C(), true), t.IS(n, Function) && n(), o = "";
      return;
    }
    return r && R();
  }
}
var N = {};
var se = ["load", "unload", "scroll", "focus", "blur", "DOMNodeRemovedFromDocument", "DOMNodeInsertedIntoDocument", "loadstart", "progress", "error", "abort", "load", "loadend", "pointerenter", "pointerleave", "readystatechange"];
var ae = (t) => !!se.find((e) => e === t);
var Ht = () => {
  let t = (n) => N[n.type].forEach((o) => o(n)), e = (n, o) => (s) => {
    let u = s.target?.closest?.(n);
    return u && o(s, y(u));
  }, r = (n, o) => {
    N[n] || addEventListener(n, t, ae(n));
  };
  return (n, o, s, u = false) => {
    r(n, u);
    let h = o ? e(o, s) : s;
    N = N[n] ? { ...N, [n]: N[n].concat(h) } : { ...N, [n]: [h] };
  };
};
var ut = ce;
function ce({ styleSheet: t, createWithId: e }) {
  let { cssRuleFromText: r, checkAtRules: n, toDashedNotation: o, IS: s, shortenRule: u, consider: h, ruleExists: x, checkParams: p, atMedia2String: w, sheet: E, compareSelectors: R } = le({ styleSheet: t, createWithId: e }), S = (i, l) => {
    if (i && l.removeProperties) {
      Object.keys(l.removeProperties).forEach((f) => {
        i.style.removeProperty(f);
      });
      return;
    }
    Object.entries(l).forEach(([f, v]) => {
      let c;
      /!important/.test(v) && (v = v.slice(0, v.indexOf("!important")).trim(), c = "important"), i.style.setProperty(o(f), v, c);
    });
  }, C = (i, l, f = E) => {
    if (!s(i, String) || !i.trim().length || /[;,]$/g.test(i.trim()))
      return console.error(`StylingFactory instance (setRules): [${i || "[no selector given]"}] is not a valid selector`);
    let v = x(i, true), c = v || f.cssRules[f.insertRule(`${i} {}`, f.cssRules.length || 0)];
    if (l.removeRule) {
      if (!v)
        return console.error(`Remove rule: ${i} does not exist`);
      let g = [...E.rules].findIndex((b) => R(b.selectorText || "", i));
      return h(() => E.deleteRule(g));
    }
    return h(() => S(c, l), i, v);
  }, M = (i) => {
    let l = i.trim().split(/{/, 2), f = l.shift().trim();
    if (!s(f, String) || !f.trim())
      return console.error(`StylingFactory instance (doParse): no (valid) selector could be extracted from rule ${u(i)}`);
    let v = r(l.shift());
    return C(f, v);
  }, m = (i) => {
    let l = n(i);
    return l.done ? l.existing : M(i);
  }, d = (i, l) => i.trim().startsWith("@media") ? m(w(i, l)) : C(i, l);
  return (i, l = {}) => p(i, l) && (Object.keys(l).length ? d(i, l) : m(i));
}
function le({ styleSheet: t, createWithId: e }) {
  let r = "Note: The rule or some of its properties may not be supported by your browser (yet)", n = (c) => c.replace(/([*\[\]()-+{}.$?\\])/g, "\\$1");
  t = e ? ((c) => document.querySelector(`#${c}`)?.sheet ?? document.head.insertAdjacentElement("beforeend", Object.assign(document.createElement("style"), { id: c, type: "text/css" })).sheet)(e) : t;
  let s = (c, ...g) => {
    let b = g.length && Array.isArray(g.slice(-1)) ? g.pop().join("") : "";
    return new RegExp((g.length && c.raw.reduce((T, G, jt) => T.concat(g[jt - 1] || "").concat(G), "") || c.raw.join("")).split(`
`).map((T) => T.replace(/\s|\/\/.*$/g, "").trim().replace(/(@s!)/g, " ")).join(""), b);
  }, u = (c, g) => [...t.rules].find((b) => g ? M(b.selectorText || "", c) : s`${n(c)}${[..."gim"]}`.test(b.cssText)), h = (c) => /@import|@charset|@font-face/i.test(c) ? { existing: i(c, 0), done: true } : w.test(c) ? { ok: i(c, t.cssRules.length), done: true } : { ok: false, done: false }, x = (c, ...g) => !!g.find((b) => p(c, b)), p = (c, ...g) => {
    if (g.length > 1)
      return x(c, ...g);
    g = g.shift();
    let b = "Invalid parameter(s)", T = c === 0 ? Number : c === "" ? String : c ? Object.getPrototypeOf(c)?.constructor : { name: b };
    return g ? g === T?.__proto__ || g === T : T?.name ?? b;
  }, w = s`@keyframes | @font-feature-values | @font-palette-values 
    | @layer | @namespace | @page | @counter-style | @container | @media ${["i"]}`, E = (c) => c.reduce((g, b) => {
    let [T, G] = [b.slice(0, b.indexOf(":")).trim(), b.slice(b.indexOf(":") + 1).trim().replace(/;$|;.+(?=\/*).+\/$/, "")];
    return T && G ? { ...g, [T]: G } : g;
  }, {}), R = (c) => c.replace(/[}{\r\n]/g, "").split(";").map((g) => g.trim()).join(`;
`).split(`
`), S = (c) => E(R(c)), C = (c) => c.replace(/[A-Z]/g, (g) => `-${g.toLowerCase()}`).replace(/[^--]^-|-$/, ""), M = (c, g) => c?.replace("::", ":") === g?.replace("::", ":"), m = (c, g) => c && p(c, String) && c.trim().length && p(g, Object) || (console.error("StylingFactory instance called with invalid parameters"), false), d = (c) => {
    let g = (c || "NO RULE").trim().slice(0, 50).replace(/\n/g, "\\n").replace(/\s{2,}/g, " ");
    return c.length > g.length ? `${g.trim()}...truncated` : g;
  }, i = (c) => {
    c = c.trim();
    let g = !!u(c.slice(0, c.indexOf("{")));
    try {
      return t.insertRule(`${c}`, t.cssRules.length), g;
    } catch (b) {
      return console.error(`StylingFactory instance (tryParse) ${b.name} Error:
${b.message}
Rule: ${d(c)}
${r}`), g;
    }
  }, l = (c, g, b) => {
    try {
      return c(), b;
    } catch (T) {
      return console.error(`StylingFactory instance (tryAddOrModify) ${T.name} Error:
${T.message}
Rule: ${d(g)}
${r}`), b;
    }
  }, f = (c) => Object.entries(c).map(([g, b]) => `${g}: ${b.trim()}`).join(`;
`);
  return { sheet: t, cssRuleFromText: S, checkAtRules: h, ruleExists: u, atMedia2String: (c, g) => `${c.trim()} ${Object.entries(g).map(([b, T]) => `${b}: { ${f(T)}`)}`, compareSelectors: M, toDashedNotation: C, checkParams: m, tryParse: i, consider: l, IS: p, shortenRule: d };
}
var mt = ct.instanceExtensions;
var At = ct.factoryExtensions;
var lt = (t) => a(t, Comment, Text);
var j = (t) => a(t, Text, HTMLElement, Comment);
var ue = (t) => a(t, Comment);
var pt = (t) => a(t, String) && /^<|>$/.test(`${t}`.trim());
var Ft = (t) => a(t, Array) && !t?.find((e) => !pt(e));
var gt = (t) => a(t, Array) && !t?.find((e) => !j(e));
var Mt = (t) => t?.filter((e) => e).reduce((e, r) => e.concat(ue(r) ? `<!--${r.data}-->` : lt(r) ? r.textContent : r.outerHTML), "");
var Rt = (t) => t ? a(t, NodeList) ? [...t] : j(t) ? [t] : gt(t) ? t : t.isJQL ? t.collection : void 0 : [];
var It = (t, e, r) => {
  let n = e !== document.body && a(t, String) && t.toLowerCase() !== "body" ? e : document, o;
  try {
    r.collection = [...n.querySelectorAll(t)];
  } catch {
    o = `Invalid CSS querySelector. [${a(t, String) ? t : "Nothing valid given!"}]`;
  }
  return o ?? `CSS querySelector "${t}", output ${r.collection.length} element(s)`;
};
var $t = (t) => {
  let e = t.data.get("hid") || `HID${V()}`;
  return t.data.add({ hid: e }), `[data-hid="${e}"]`;
};
var W = (t) => {
  let e = (s) => (...u) => a(s, Function) && s(W(t), ...u), r = (s) => (...u) => a(s, Function) ? { tmpKey: s(W(t), ...u) } : { tmpKey: void 0 }, n = (s, u) => a(u, Symbol) ? () => s : a(+u, Number) ? s.collection?.[u] : u in At ? r(At[u])().tmpKey : u in mt ? e(mt[u]) : s[u], o = { get: (s, u) => n(s, u) };
  return new Proxy(t, o);
};
var dt = ut({ createWithId: "JQLStylesheet" });
var de = (t, e) => mt[t] = (r, ...n) => e(r, ...n);
var me;
var Dt = (t) => {
  let e = pe(t);
  return Object.entries(Object.getOwnPropertyDescriptors(e)).forEach(([r, n]) => {
    Object.defineProperty(t, r, n);
  }), me = { ...e }, t;
};
function pe(t) {
  let e = { activePopup: void 0 }, r = document.createElement("br"), n = (...m) => m.forEach((d) => dt(d)), o = (m, d) => dt(m, d), s = (m, d, i) => {
    d = d?.isJQL ? d?.[0] : d, i = i && Object.values(H).find((f) => i === f) ? i : void 0;
    let l = t(m, r);
    return d && !a(d, HTMLBRElement) && l.collection.forEach((f) => i ? d.insertAdjacentElement(i, f) : d.append(f)), l;
  }, u = Ht(), h = (m, d, ...i) => (a(d, Function) && (i.push(d), d = void 0), i.forEach((l) => u(m, d, l))), x = Object.entries(D.tagsRaw).reduce(C, {}), p = (...m) => {
    if (m.length === 1) {
      let d = String(m.shift().trim());
      m = d.startsWith("!") ? [d.slice(1, -1)] : d.split(",").map((i) => i.trim());
    }
    m.map((d) => d.startsWith("!") ? d.slice(1, -1) : d).forEach((d) => dt(d, { removeRule: 1 }));
  }, w = Object.entries(D.tagsRaw).filter(([, m]) => m).map(([m]) => m).sort((m, d) => m.localeCompare(d));
  return M(x, ((m) => ({ debugLog: $, log: (...i) => A("fromStatic", ...i), insertPositions: H, get at() {
    return H;
  }, editCssRules: n, editCssRule: o, setStyle: o, delegate: h, virtual: s, get fn() {
    return de;
  }, get allowTag() {
    return D.allowTag;
  }, get prohibitTag() {
    return D.prohibitTag;
  }, get lenient() {
    return D.allowUnknownHtmlTags;
  }, get IS() {
    return a;
  }, popup: () => m.Popup, get Popup() {
    return m.activePopup || (m.activePopup = Tt(m)), m.activePopup;
  }, createStyle: (i) => ut({ createWithId: i || `jql${V()}` }), removeCssRule: p, removeCssRules: p, text: (i, l = false) => l ? document.createComment(i) : document.createTextNode(i), comment: (i) => m.text(i, true), node: (i, l = document) => l.querySelector(i, l), nodes: (i, l = document) => [...l.querySelectorAll(i, l)] }))(t));
  function R({ tag: m, content: d = "", cssClass: i = "", props: l = {}, toDOM: f = false } = {}) {
    let v = t.virtual(`<${m}></${m}>`);
    return (a(d, String, HTMLElement, Array) || d.isJQL) && (a(d, Array) || (d = [d]), v.append(...d)), a(l, Object) && v.prop(l), i && (i = a(i, Array) ? i : [i], v.addClass(...i)), f ? v.toDOM() : v;
  }
  function S(m) {
    function d(i) {
      return i.toUpperCase() === i ? t.virtual(`<${i}></${i}>`) : (l, f = {}) => R(!l.isJQL && a(l, Object) ? { tag: i, ...l } : { tag: i, content: l, props: f });
    }
    return { get() {
      return d(m);
    } };
  }
  function C(m, [d, i]) {
    if (!i)
      return m;
    let l = d.toUpperCase();
    return Object.defineProperty(m, d, S(d)), Object.defineProperty(m, l, S(l)), m;
  }
  function M(...m) {
    let d = {};
    for (let i of m) {
      let l = Object.getOwnPropertyDescriptors(i);
      Object.entries(l).forEach(([f, v]) => Object.defineProperty(d, f, v));
    }
    return d;
  }
}
var y = Dt(ge());
function ge() {
  return function(r, n, o = H.BeforeEnd) {
    let s = a(n, HTMLBRElement);
    n = s && document.body || (n && n?.isJQL ? n[0] : n) || document.body, o = o && Object.values(H).find((S) => o === S) ? o : void 0;
    let u = pt(r), h = !u && Ft(r), x = h || u, p = { collection: Rt(r) ?? [], isVirtual: s, isJQL: true }, w = gt(p.collection);
    location.host.startsWith("dev") && (p.params = { virtual: p.isVirtual, jql: p.isJQL, isRawHtml: u, isRawHtmlArray: h, isRawElemCollection: w });
    let E = `input =&gt; ${h ? `"${I(r.join(", "), 70)}"` : !x && w ? `element collection [${I(p.collection.map((S) => `${a(S, Comment, Text) ? "Comment|Text @" : ""} ${S.outerHTML || S.textContent}`).join(", "), 70)}]` : `"${I(r, 70)}"`}`;
    if (p.collection.length && w)
      return B(E), s || p.collection.forEach((S) => {
        n.contains(S) || z([S], n, o);
      }), W(p);
    if (x) {
      if ([r].flat().forEach((S) => p.collection.push(F(S))), p.collection.length > 0) {
        let S = p.collection.filter((C) => C?.dataset?.jqlcreationerror);
        p.collection = p.collection.filter((C) => !C?.dataset?.jqlcreationerror), B(`${E}`), B(`*Created ${p.isVirtual ? "VIRTUAL " : ""}[${I(Mt(p.collection) || "sanitized: no elements remaining", 70)}]`), S.length && console.error(`JQL: illegal html, not rendered: "${S.reduce((C, M) => C.concat(`${M.textContent}
`), "").trim()}"`), p.isVirtual || z(p.collection, n, o);
      }
      return W(p);
    }
    let R = It(r, n, p);
    return B(`input => ${R}`), W(p);
  };
}

// node_modules/protoxt/index.js
var getValidatedTargets = (targets) => ({
  targets: [].concat(targets).map((obj) => obj && obj.prototype),
  get invalid() {
    return this.targets.find((v) => v === null || v === void 0 || v.prototype && Object.getPrototypeOf(v.prototype || 0).constructor !== Object);
  }
});
var isArrow = (f) => !`${f}`.trim().startsWith(`function`);
var length = addSimple([Function.prototype], hasArgs);
var noCando = (targets, fn) => {
  const error = targets.invalid || targets.invalid === null ? `ProtoXT: (one of) the target(s) is not valid.` : !(fn instanceof Function) ? `ProtoXT: [fn] *must* be a Function instance.` : false;
  error && console.error(error);
  return !!error;
};
function add(targetOrTargets, fn, { outerSyntax = false, symbolName = fn?.name, asProperty = false } = {}) {
  const targetsChecked = getValidatedTargets([targetOrTargets].flat());
  return noCando(targetsChecked, fn) ? false : fn[length] ? outerSyntax || asProperty ? addProperty(targetsChecked.targets, fn, { symbolName, asProperty }) : addWithParams(targetsChecked.targets, fn, { symbolName }) : addSimple(targetsChecked.targets, fn, { symbolName });
}
function addProperty(targetOrTargets, f, { symbolName = f?.name, asProperty = false } = {}) {
  const s = Symbol(symbolName);
  targetOrTargets.forEach((target) => {
    if (asProperty) {
      Object.defineProperty(target, s, {
        configurable: true,
        get: isArrow(f) ? function(...args) {
          return f(this, ...args);
        } : f
      });
      return;
    }
    target[s] = isArrow(f) ? function(...args) {
      return f(this, ...args);
    } : f;
    target[s].configurable = true;
  });
  return s;
}
function addWithParams(targetOrTargets, f, { symbolName = f?.name } = {}) {
  const s = Symbol(symbolName);
  return {
    intermediate: function(...args) {
      targetOrTargets.forEach((target) => Object.defineProperty(target, s, {
        configurable: true,
        get: function() {
          return isArrow(f) ? f(this, ...args) : f.apply(this, args);
        }
      }));
      return s;
    }
  }.intermediate;
}
function addSimple(targetOrTargets, f, { symbolName = f?.name } = {}) {
  const s = Symbol(symbolName);
  targetOrTargets.forEach((target) => Object.defineProperty(target, s, {
    configurable: true,
    get: isArrow(f) ? function() {
      return f(this);
    } : f
  }));
  return s;
}
function hasArgs() {
  const checkArgs = (fn) => {
    const matched = String(fn).replace(RegExp(`\\s+|function|${fn.name}`, `g`), ``).match(/^\((?<multi>([^\)]+?))\)|(?<single>[a-z_,=]+?)?=>|{/).groups;
    return matched.multi || matched.single;
  };
  return this.length || checkArgs(this);
}

// node_modules/datefiddler/datefiddler.js
var datefiddler_default = dateFiddleFactory;
function dateFiddleFactory(extensions) {
  const units = {
    year: `FullYear`,
    month: `Month`,
    date: `Date`,
    day: `Date`,
    hour: `Hours`,
    minute: `Minutes`,
    second: `Seconds`,
    millisecond: `Milliseconds`
  };
  return function(date = /* @__PURE__ */ new Date(), formatter = (d) => d) {
    return instatiate(date, !(formatter instanceof Function) ? (d) => d : formatter);
  };
  function instatiate(thisDate, formatter) {
    let _date = thisDate;
    let _initial = new Date(thisDate);
    let instance = {
      toString() {
        return instance.value.toString();
      },
      reset() {
        return instance.set(_initial);
      },
      update2Current() {
        return instance.set(new Date(_date), true);
      },
      set date(d) {
        _date = new Date(d);
      },
      set initial(d) {
        _initial = new Date(d);
      },
      get date() {
        return _date;
      },
      get initial() {
        return _initial;
      },
      get value() {
        return formatter(instance.date);
      },
      get ISO() {
        return instance.date.toISOString();
      },
      clone(nwFormatter) {
        return instatiate(new Date(_date), nwFormatter || formatter);
      },
      set: function(nwValue, all = false) {
        instance.date = _date = new Date(nwValue);
        instance.initial = _initial = all ? new Date(_date) : _initial;
        return instance;
      },
      add(...things2AddOrSubtract) {
        const allInOne = things2AddOrSubtract.length === 1 && things2AddOrSubtract.shift()?.split(/,/);
        if (allInOne && allInOne.length) {
          things2AddOrSubtract = allInOne.map((v) => v.trim());
        }
        if (things2AddOrSubtract.length) {
          things2AddOrSubtract.map(function(a2) {
            return a2.toLowerCase().split(/\s/);
          }).forEach(
            function([n, term]) {
              const unit = units[term?.replace(/s$/i, ``)];
              if (+n && unit) {
                _date[`set${unit}`](_date[`get${unit}`]() + +n);
              }
            }
          );
        }
        return instance;
      }
    };
    instance.set(thisDate);
    if (extensions) {
      Object.entries(extensions(instance)).forEach(([ext, fn]) => instance[ext] = fn);
    }
    return Object.freeze(instance);
  }
}

// node_modules/intl-dateformatter/index.js
var intl_dateformatter_default = DateFormatFactory();
function DateFormatFactory() {
  const [digits, numeric, long, short] = [`2-digit`, `numeric`, `long`, `short`];
  const theOptions = {
    fixed: {
      MM: { month: long },
      M: { month: short },
      m: { month: numeric },
      mm: { month: digits },
      yyyy: { year: numeric },
      yy: { year: digits },
      WD: { weekday: long },
      wd: { weekday: short },
      d: { day: numeric },
      dd: { day: digits },
      h: { hour: numeric },
      hh: { hour: digits },
      mi: { minute: numeric },
      mmi: { minute: digits },
      s: { second: numeric },
      ss: { second: digits },
      ms: { fractionalSecondDigits: 3 },
      tz: { timeZoneName: `shortOffset` },
      dl: { locale: `default` },
      h12: { hour12: true },
      yn: { yearName: `` },
      ry: { relatedYear: true },
      msp: { fractionalSecond: true }
    },
    dynamic: {
      tzn: (v) => ({ timeZoneName: v.slice(4) }),
      hrc: (v) => ({ hourCycle: `h${v.slice(4)}` }),
      ds: (v) => ({ dateStyle: v.slice(3) }),
      ts: (v) => ({ timeStyle: v.slice(3) }),
      tz: (v) => ({ timeZone: v.slice(3) }),
      e: (v) => ({ era: v.slice(2) }),
      l: (v) => ({ locale: v.slice(2) })
    }
  };
  const dtfOptions = {
    ...theOptions,
    retrieveDyn(fromValue) {
      const key = fromValue?.slice(0, fromValue.indexOf(`:`));
      return theOptions.dynamic[key] && theOptions.dynamic[key](fromValue);
    },
    get re() {
      return new RegExp(`\\b(${Object.keys(theOptions.fixed).join(`|`)})\\b`, `g`);
    }
  };
  const extractFromTemplate = (rawTemplateString = `dtf`, plainTextIndex = 0) => {
    let formatStr = ` ${rawTemplateString.replace(/(?<=\{)(.+?)(?=})/g, (_2) => `[${plainTextIndex++}]`).replace(/[{}]/g, ``).trim()} `;
    const texts = rawTemplateString.match(/(?<=\{)(.+?)(?=})/g) || [];
    return {
      get texts() {
        return texts;
      },
      formatString(v) {
        formatStr = v;
      },
      set formatStr(v) {
        formatStr = v;
      },
      get formatStr() {
        return formatStr;
      },
      get units() {
        return formatStr.match(dtfOptions.re) || [];
      },
      finalize(dtf = ``, h12 = ``, era = ``, yn = ``) {
        return formatStr.replace(/~(\d+?)/g, `$1`).replace(/dtf/, dtf).replace(/era/, era).replace(/dp\b/, h12).replace(/yn\b/, yn).replace(/\[(\d+?)]/g, (_2, d) => texts[d].trim()).trim();
      }
    };
  };
  const unSpacify = (str) => str.replace(/\s+/g, ``);
  const getOpts = (...opts) => opts?.reduce(
    (acc, optValue) => ({ ...acc, ...dtfOptions.retrieveDyn(optValue) || dtfOptions.fixed[optValue] }),
    dtfOptions.fixed.dl
  );
  const dtNoParts = (date, xTemplate, moreOptions) => {
    const opts = getOpts(...unSpacify(moreOptions).split(`,`));
    const formatted = Intl.DateTimeFormat(opts.locale, opts).format(date);
    return xTemplate.finalize(formatted);
  };
  const dtFormatted = (date, xTemplate, moreOptions) => {
    const optsCollected = getOpts(...xTemplate.units.concat(unSpacify(moreOptions).split(`,`)).flat());
    const opts = { ...dtfOptions.fixed };
    const checkNumeric = (type, value) => optsCollected[type] === `numeric` && value.startsWith(`0`) ? value.slice(1) : value;
    const dtf = Intl.DateTimeFormat(optsCollected.locale, optsCollected).formatToParts(date).reduce((parts, v) => v.type === `literal` ? parts : { ...parts, [v.type]: checkNumeric(v.type, v.value) }, {});
    opts.ms = optsCollected.fractionalSecondDigits ? opts.msp : opts.ms;
    opts.yyyy = dtf.relatedYear ? opts.ry : opts.yyyy;
    xTemplate.formatStr = xTemplate.formatStr.replace(dtfOptions.re, (dtUnit) => dtf[Object.keys(opts[dtUnit]).shift()] || dtUnit);
    return xTemplate.finalize(...[, dtf.dayPeriod, dtf.era, dtf.yearName]);
  };
  return (date, template, moreOptions = `l:default`) => /ds:|ts:/.test(moreOptions) ? dtNoParts(...[date, extractFromTemplate(void 0), moreOptions]) : dtFormatted(...[date, extractFromTemplate(template || void 0), moreOptions]);
}

// node_modules/jsregexphelper/RegexpCreator.js
var RegexpCreator_default = (regexStr, ...args) => {
  const flags = args.length && Array.isArray(args.slice(-1)) ? args.pop().join(``) : ``;
  return new RegExp(
    (args.length && regexStr.raw.reduce((a2, v, i) => a2.concat(args[i - 1] || ``).concat(v), ``) || regexStr.raw.join(``)).split(`
`).map((line) => line.replace(/\s|\/\/.*$/g, ``).trim().replace(/(@s!)/g, ` `)).join(``),
    flags
  );
};

// index.js
var xDate = datefiddler_default(dateFiddlerExtentions);
var dtDiffCalc = dateDiffFactory();
var IS = y.IS;
setDefaultStyling();
fixSBLinks2TopProblem();
function fixSBLinks2TopProblem() {
  console.info(`\u2714 Stackblitz rewrites links to _top. The 'stackblitzhelpers' module fixed it.`);
  document.addEventListener(`click`, (evt) => {
    if (evt.target.href) {
      const ref = evt.target;
      if (ref.dataset.top || ref.classList.contains(`internalLink`) || ref.target === `_top`) {
        return top.location.href = ref.href;
      }
    }
    return true;
  });
}
function logFactory(formatJSON = true) {
  const logContainer = y(`<ul id="log2screen"/>`);
  const toJSON = (content) => tryJSON(content, formatJSON);
  const createItem = (t) => y(`${t}`.startsWith(`!!`) ? `<li class="head">` : `<li>`);
  const logPosition = { top: logContainer.prepend, bottom: logContainer.append };
  const cleanContent = (content) => !y.IS(content, String, Number) ? toJSON(content) : `${content}`;
  const writeLogEntry = (content) => createItem(content).append(y(`<div>${content?.replace(/^!!/, ``)}</div>`));
  const logItem = (pos = `bottom`) => (content) => logPosition[pos](writeLogEntry(cleanContent(content)));
  return {
    log: (...txt) => txt.forEach(logItem()),
    logTop: (...txt) => txt.forEach(logItem(`top`))
  };
}
function tryJSON(content, formatted) {
  try {
    return formatted ? `<pre>${JSON.stringify(content, null, 2)}</pre>` : JSON.stringify(content);
  } catch (err) {
    return `Some [Object object] can not be converted to JSON`;
  }
}
function dateFiddlerExtentions(instance) {
  const add2 = (toAdd) => instance.add(toAdd);
  return {
    nextWeek: (_2) => add2(`7 days`),
    previousWeek: (_2) => add2("-7 days"),
    addWeeks: (n = 1) => add2(`${n * 7} days`),
    nextYear: (_2) => add2("1 year"),
    previousYear: (_2) => add2("-1 year"),
    addYears: (n = 1) => add2(`${n} years`),
    nextMonth: (_2) => add2("1 month"),
    previousMonth: (_2) => add2("-1 month"),
    addMOnths: (n = 1) => add2(`${n} months`),
    tomorrow: (_2) => add2("1 day"),
    yesterday: (_2) => add2("-1 day"),
    addDays: (n = 1) => add2(`${n} days`)
  };
}
function dateDiffFactory() {
  const checkParams = (start, end) => {
    if (!end && !start || (!IS(start, Date) || !IS(end, Date))) {
      const [message, full, clean] = Array(3).fill(`please provide a (valid) start and end Date!`);
      return { error: true, message, full, clean };
    }
    if (!end) {
      const [message, full, clean] = Array(3).fill(`please provide a (valid) end Date!`);
      return { error: true, message, full, clean };
    }
    if (!start) {
      const [message, full, clean] = Array(3).fill(`please provide a start Date!`);
      return { error: true, message, full, clean };
    }
    return { error: false };
  };
  const stringify = stringifyComposed();
  return function getDifference({ start, end } = {}) {
    const checks = checkParams(start, end);
    if (checks.error) {
      return checks;
    }
    const date1 = new Date(start);
    const date2 = new Date(end);
    const differenceMs = Math.abs(date2 - date1);
    const differenceDate = new Date(differenceMs);
    const years = differenceDate.getUTCFullYear() - 1970;
    const months = differenceDate.getUTCMonth();
    const days = differenceDate.getUTCDate() - 1;
    const seconds = Math.floor(differenceMs / 1e3 % 3600 % 60);
    const minutes = Math.floor(differenceMs / 6e4 % 60);
    const hours = Math.floor(differenceMs / 36e5 % 24);
    const milliseconds = Math.floor(differenceMs % 1e3);
    const diffs = { years, months, days, hours, minutes, seconds, milliseconds };
    diffs.full = stringify({ values: diffs, full: true });
    diffs.clean = stringify({ values: diffs });
    return diffs;
  };
  function stringifyComposed() {
    const pipe = (...functions) => (initial) => functions.reduce((param, func) => func(param), initial);
    const singleOrMultiple = (numberOf, term) => numberOf === 1 ? term.slice(0, -1) : term;
    const filterRelevant = ({ values, full }) => [Object.entries(values).filter(([key]) => /^(years|month|days|hours|minutes|seconds)/i.test(key)), full];
    const aggregateDiffs = ([diffs, full]) => full ? diffs : diffs.filter(([, value]) => full ? +value : value > 0);
    const stringifyDiffs = (diffsFiltered) => diffsFiltered.reduce((acc, [key, value]) => [...acc, `${value} ${singleOrMultiple(value, key)}`], []);
    const diffs2SingleString = (diffStrings) => diffStrings.length < 1 ? `Dates are equal` : `${diffStrings.slice(0, -1).join(`, `)}${diffStrings.length > 1 ? ` and ` : ``}${diffStrings.slice(-1).shift()}`;
    return pipe(filterRelevant, aggregateDiffs, stringifyDiffs, diffs2SingleString);
  }
}
function setDefaultStyling() {
  y.editCssRules(...[
    `body { 
      font: normal 14px/17px  system-ui, sans-serif;
      margin: 1rem;
     }`,
    `code {
      color: green;
      background-color: #eee;
      padding: 2px;
      font-family: monospace;
    }`,
    `code.codeblock {
      display: block;
      padding: 6px;
      border: 1px solid #999;
      margin: 0.5rem 0; 
      background-color: #eee;
      white-space: pre-wrap;
    }`,
    `h3 {marginTop: 1.5rem;}`,
    `.thickBorder {
      border: 5px solid green;
      borderWidth: 5px;
      padding: 0.5rem;
      display: inline-block; 
    }`,
    `a.ExternalLink {
      text-decoration: none;
      color: rgb(0, 0, 238);
      background-color: #EEE;
      padding: 3px;
      font-weight: bold;
    }`,
    `.cmmt {
      color: #888;
    }`,
    `.hidden {display: none;}`,
    `.attention {color: red; font-size: 1.2em; font-weight: bold;}`,
    `#log2screen li { 
      listStyle: '\\2713'; 
      paddingLeft: 6px; 
      margin: 0.5rem 0 0 -1.2rem; 
      font-family: monospace 
    }`,
    `#log2screen li.head {
      list-style-type: none;
      font-weight: bold;
      margin-top: 0.8rem;
      margin-bottom: -0.2rem;
      font-family: revert;
    }`,
    `.err {fontStyle: italic; color: red; }`,
    `a {text-decoration:none; font-weight:bold;}`,
    `a:hover {text-decoration: underline;}`,
    `a[target]:before, a.internalLink:before, a.externalLink:before {
      color: rgba(0,0,238,0.7);
      font-size: 1.1rem;
      padding-right: 2px;
      vertical-align: baseline;
     }`,
    `a[target="_blank"]:before, a.externalLink:before {
      content: '\\2197';
     }`,
    `a[data-top]:before, a.internalLink:before, a[target="_top"]:before {
      content: '\\21BA';
     }`
  ]);
}
export {
  y as $,
  dtDiffCalc,
  intl_dateformatter_default as dtFormat,
  add as extendSymbolic,
  logFactory,
  RegexpCreator_default as regexhelper,
  xDate
};
